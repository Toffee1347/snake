<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.4.1/css/bootstrap.min.css">
    <link rel='stylesheet' href='https://fonts.googleapis.com/css?family=Trispace'>
    <link rel="stylesheet" href="/style.css">
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.4.1/js/bootstrap.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tsparticles/1.18.1/tsparticles.min.js" integrity="sha512-PYHWDEuXOTJ9MZ+/QHqkbgiEYZ+LImQv3i/9NyYOABFvK37e4q4Wg7aQDN1JpoGiEu1TYZh6JMrZluZox2gbDA==" crossorigin="anonymous"></script>
    <script src="/socket.io/socket.io.js"></script>
    <script src="/token_script.js"></script>
    <title>Snake</title>
    <style>
        body {
            overscroll-behavior: contain;
        }
    </style>
</head>
<body style="margin: 0px;">
    <div id="particles-js"></div>
    <div class="center"> 
        <div class="game">
            <div style="margin: 20px; margin-bottom: 35px;"><div style="float: left;">Score: <x id="score">0</x></div><div style="float: right;">Time: <x id="time">00:00</x></div></div><br>
            <canvas id="game_canvas" width="300" height="300">Your browser doesn't support canvases!</canvas>
        </div>
    </div>
    <script>
        class Snake {
            constructor(id, startLength, blockSize, settings, scoreId) {
                this.canvas = document.getElementById(id).getContext('2d')
                this.id = id
                this.startLength = startLength
                this.settings = settings
                this.snake = [{x:document.getElementById(id).width / 2 - (startLength * blockSize), y:document.getElementById(id).height / 2}]
                this.food = {x:0, y:0}
                this.velocety = {x:0, y:0}
                this.blockSize = blockSize
                this.changingDirection = false
                this.score = 0
                this.scoreId = scoreId
                this.running = false
            }
            async start() {
                this.running = true
                for (let x = 1; x < this.startLength; x++) {
                    this.snake.unshift({x:this.snake[this.snake.length - 1].x + this.blockSize * x, y:this.snake[this.snake.length - 1].y})
                }
                document.addEventListener('keydown', this.keyPress.bind(this))
                this.clearCanvas()
                this.createFood()
                this.drawFood()
                this.drawSnake()
                this.velocety.x = this.blockSize
                setInterval(() => {
                    if (!this.running) return
                    if (this.gameEnded()) {
                        alert('You lost!')
                        window.location.href = '/single/start'
                    }
                    this.changingDirection = false
                    this.clearCanvas()
                    this.advanceSnake()
                    this.drawSnake()
                    this.drawFood()
                }, this.settings.game_speed)
            }
            random(min, max) {
                return Math.round(Math.random() * (max-min) + min);
            }
            clearCanvas() {
                this.canvas.fillStyle = this.settings.canvas_background_colour
                this.canvas.strokeStyle = this.settings.canvas_border_colour
                this.canvas.fillRect(0, 0, document.getElementById(this.id).width, document.getElementById(this.id).height)
                this.canvas.strokeRect(0, 0, document.getElementById(this.id).width, document.getElementById(this.id).height)
            }
            drawFood() {
                this.canvas.fillStyle = this.settings.food_colour
                this.canvas.strokeStyle = this.settings.food_border_colour
                this.canvas.fillRect(this.food.x, this.food.y, this.blockSize, this.blockSize)
                this.canvas.strokeRect(this.food.x, this.food.y, this.blockSize, this.blockSize)
            }
            createFood() {
                this.food.x = this.random(0, document.getElementById(this.id).width - this.blockSize)
                this.food.y = this.random(0, document.getElementById(this.id).height - this.blockSize)
                this.snake.forEach((part) => {
                    if (part.x === this.food.x && part.y === this.food.y) this.createFood()
                })
            }
            drawSnake() {
                this.canvas.fillStyle = this.settings.snake_colour
                this.canvas.strokeStyle = this.settings.snake_border_colour
                this.snake.forEach((part) => {
                    this.canvas.fillRect(part.x, part.y, this.blockSize, this.blockSize)
                    this.canvas.strokeRect(part.x, part.y, this.blockSize, this.blockSize)
                })
            }
            advanceSnake() {
                this.snake.unshift({x:this.snake[0].x + this.velocety.x, y:this.snake[0].y + this.velocety.y})
                if (this.snake[0].x === this.food.x && this.snake[0].y === this.food.y) {
                    this.addScore(10)
                    this.createFood()
                }
                else {
                    this.snake.pop()
                }
            }
            gameEnded() {
                for (let i = 1; i < this.snake.length; i++) {
                    if (this.snake[i].x === this.snake[0].x && this.snake[i].y === this.snake[0].y) {
                        return true
                    }
                    const hit = {
                        left_wall: this.snake[0].x < 0,
                        right_wall: this.snake[0].x > document.getElementById(this.id).width - this.blockSize,
                        top_wall: this.snake[0].y < 0,
                        bottom_wall: this.snake[0].y > document.getElementById(this.id).height - this.blockSize
                    }
                    return hit.left_wall || hit.right_wall || hit.top_wall || hit.bottom_wall
                }
            }
            keyPress(event) {
                if (this.changingDirection) {
                    return
                }
                this.changingDirection = true
                if (event.keyCode == this.settings.up && this.velocety.y != -10) {
                    this.velocety =  {
                        x:0,
                        y:-10
                    }
                }
                else if (event.keyCode == this.settings.down && this.velocety.y != 10) {
                    this.velocety =  {
                        x:0,
                        y:10
                    }
                }
                else if (event.keyCode == this.settings.left && this.velocety.x != -10) {
                    this.velocety =  {
                        x:-10,
                        y:0
                    }
                }
                else if (event.keyCode == this.settings.right && this.velocety.x != 10) {
                    this.velocety =  {
                        x:10,
                        y:0
                    }
                }
            }
            addScore(amount) {
                this.score += amount
                document.getElementById(this.scoreId).innerHTML = this.score
            }
        }
    </script>
    <script>
        document.addEventListener('click', () => {
            document.documentElement.requestFullscreen()
        })
        let timeCount = 0
        let timerID = setInterval(() => {
            if (settings.game_time <= timeCount) {
                alert(`You survived for ${settings.game_time} seconds with a score of ${score}`)
                window.location.href = '/single/start'
            }
            timeCount++
            timer = new Date(settings.game_time * 1000 - timeCount * 1000)
            document.getElementById('time').innerHTML = `0${timer.getMinutes()}`.slice(-2) + ':' + `0${timer.getSeconds()}`.slice(-2)
        }, 1000)

        let origMouse
        document.addEventListener('touchstart', (e) => {mouseDown(e.touches[0].clientX, e.touches[0].clientY)})
        document.addEventListener('touchend', (e) => {mouseUp(e.changedTouches[0].clientX, e.changedTouches[0].clientY)})
        function mouseDown(x, y) {
            origMouse = {
                X:x,
                Y:y
            }
        }
        function mouseUp(x, y) {
            const mouseDiff = {
                x:origMouse.X - x,
                y:origMouse.Y - y
            }
            if (Math.abs(mouseDiff.x) > Math.abs(mouseDiff.y)) {
                if (Math.abs(mouseDiff.x) < screenX/10) return
                if (Math.sign(mouseDiff.x) == 1) {
                    change_direction({keyCode:localStorage.getItem('left')})
                }
                else if (Math.sign(mouseDiff.x) == -1) {
                    change_direction({keyCode:localStorage.getItem('right')})
                }
            }
            else if (Math.abs(mouseDiff.x) < Math.abs(mouseDiff.y)) {
                if (Math.abs(mouseDiff.y) < screenY/10) return
                if (Math.sign(mouseDiff.y) == 1) {
                    change_direction({keyCode:localStorage.getItem('up')})
                }
                else if (Math.sign(mouseDiff.y) == -1) {
                    change_direction({keyCode:localStorage.getItem('down')})
                }
            }
        }
        /*let snake = [
            {x: 150, y: 150},
            {x: 140, y: 150},
            {x: 130, y: 150},
            {x: 120, y: 150},
            {x: 110, y: 150}
        ]
        let food = {
            x:'',
            y:''
        }
        let score = 0
        let changeing_direction = false
        let d = {
            x:10,
            y:0
        }*/
        let required_settings = [
            ['game_speed', '250'],
            ['canvas_border_colour', '#000000'],
            ['canvas_background_colour', '#ffffff'],
            ['snake_colour', '#90ee90'],
            ['snake_border_colour', '#013220'],
            ['food_colour', '#ff0000'],
            ['food_border_colour', '#8b0000'],
            ['up', 38],
            ['down', 40],
            ['left', 37],
            ['right', 39],
            ['up_key', 'ArrowUp'],
            ['down_key', 'ArrowDown'],
            ['left_key', 'ArrowLeft'],
            ['right_key', 'ArrowRight'],
            ['game_time', 120]
        ]
        let settings = {
            game_speed:250,
            canvas_border_colour:'#000000',
            canvas_background_colour:'#ffffff',
            snake_colour:'#90ee90',
            snake_border_colour:'#013220',
            food_colour:'#ff0000',
            food_border_colour:'#8b0000',
            up:38,
            down:40,
            left:37,
            right:39,
            up_key:'ArrowUp',
            down_key:'ArrowDown',
            left_key:'ArrowLeft',
            right_key:'ArrowRight',
            game_time:120
        }
        for (const x of required_settings) {
            if (!localStorage.getItem(x[0])) {
                localStorage.setItem(x[0], x[1])
            }
            else {
                settings[x[0]] = localStorage.getItem(x[0])
            }
        }
        let timer = new Date(settings.game_time * 1000)
        document.getElementById('time').innerHTML = `0${timer.getMinutes()}`.slice(-2) + ':' + `0${timer.getSeconds()}`.slice(-2)
        function add_score(amount) {
            score += amount
            document.getElementById('score').innerHTML = score
        }
        /*const canvas = document.getElementById('game_canvas')
        const ctx = canvas.getContext("2d")

        clear_canvas()
        run_game()
        create_food()
        document.addEventListener('keydown', change_direction)

        function run_game() {
            if (did_game_end()) return end_game()
            setTimeout(() => {
                changeing_direction = false
                clear_canvas()
                draw_food()
                advance_snake()
                draw_snake()
                run_game()
            }, settings.game_speed)
        }
        function clear_canvas() {
            ctx.fillStyle = settings.canvas_background_colour
            ctx.strokeStyle = settings.canvas_border_colour
            ctx.fillRect(0, 0, canvas.width, canvas.height)
            ctx.strokeRect(0, 0, canvas.width, canvas.height)
        }
        function draw_food() {
            ctx.fillStyle = settings.food_colour
            ctx.strokeStyle = settings.food_border_colour
            ctx.fillRect(food.x, food.y, 10, 10)
            ctx.strokeRect(food.x, food.y, 10, 10)
        }
        function advance_snake() {
            snake.unshift({x:snake[0].x + d.x, y:snake[0].y + d.y})
            if (snake[0].x === food.x && snake[0].y === food.y) {
                add_score(10)
                create_food()
            }
            else {
                snake.pop()
            }
        }
        function did_game_end() {
            for (let i = 4; i < snake.length; i++) {
                if (snake[i].x === snake[0].x && snake[i].y === snake[0].y) {
                    return true
                }
                const hit = {
                    left_wall: snake[0].x < 0,
                    right_wall: snake[0].x > canvas.width - 10,
                    top_wall: snake[0].y < 0,
                    bottom_wall: snake[0].y > canvas.height - 10
                }
                return hit.left_wall || hit.right_wall || hit.top_wall || hit.bottom_wall
            }
        }
        function random(min, max) {
            return Math.round(Math.random() * (max-min) + min);
        }
        function create_food() {
            food.x = random(0, canvas.width - 10)
            food.y = random(0, canvas.height - 10)
            snake.forEach((part) => {
                if (part.x === food.x && part.y === food.y) create_food()
            })
        }
        function draw_snake() {
            snake.forEach(draw_snake_part)
        }
        function draw_snake_part(part) {
            ctx.fillStyle = settings.snake_colour
            ctx.strokeStyle = settings.snake_border_colour
            ctx.fillRect(part.x, part.y, 10, 10)
            ctx.strokeRect(part.x, part.y, 10, 10)
        }
        function change_direction(event) {
            if (changeing_direction) return;
            changeing_direction = true
            if (event.keyCode == settings.up && d.y != 10) {
                d = {
                    x:0,
                    y:-10
                }
            }
            if (event.keyCode == settings.down && d.y != -10) {
                d = {
                    x:0,
                    y:10
                }
            }
            if (event.keyCode == settings.left && d.x != 10) {
                d = {
                    x:-10,
                    y:0
                }
            }
            if (event.keyCode == settings.right && d.x != -10) {
                d = {
                    x:10,
                    y:0
                }
            }
        }
        async function end_game() {
            alert(`You died and survived for ${timeCount} seconds with a score of ${score}`)
            window.location.href = '/single/start'
        }*/
    </script>
</body>
</html>